<!DOCTYPE html>
<!-- Initial code was (long ago) 04_force.html by Scott Murray -->
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Network transition</title>
        <script src="include/js/d3.v3.js" charset="utf-8"></script>
        <script src="include/js/d3.slider.js" charset="utf-8"></script>
        <link rel="stylesheet" href="include/css/d3.slider.css" />
        <link rel="stylesheet" href="include/css/styles.css" />   
    </head>
    <body>
        <div id='conteneurPrincipal'>
            <div id='step'></div>
            <div>Slider with slide event: <span id="slidertext">1</span></div>
            <div id='slider'></div>
            <div id='conteneurReseau'></div>
            <div id='conteneurTexte'>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quaerat voluptate dignissimos maxime adipisci asperiores cumque, ut eum earum consequuntur odio laboriosam aut nihil laudantium soluta, et, nulla veniam quod similique.</div>
        </div>
        <script type="text/javascript">
        // ajout d'une closure, à limiter aux variables globales une fois le script finalisé
        (function (){
            // Largeur et hauteur de la fenêtre où apparaît le réseau
            var w = 640;
            var h = 480;
            
            // La rapidité d'animation en ms
            var step_duration = 100;

            // whichstep nous donne l'état du réseau
            var whichstep = 0;

            // La variable temp permet d'appeler le tableau de données en dehors de d3.tsv, par exemple dans la console
            var temp = [];

            // Importation des noeuds et gestion des fichiers à l'intérieur de la fonction d3.tsv
            // pour pallier aux problèmes d'asychronisme de JavaScript
            d3.tsv("../data/moliere/l_ecole_des_femmes_personnages.txt", function(d) {

                // On sélectionne le div dont l'"id" est "step"
                var element = document.getElementById("step");

                // Dans ce div, on ajoute quatre paragraphes chacun suivi d'un nombre lui correspondant
                element.innerHTML = "<p>Pièce</p>"      + d[whichstep].piece 
                                  + "<p>Acte</p>"       + d[whichstep].acte  
                                  + "<p>Scène</p>"      + d[whichstep].scene 
                                  + "<p>Réplique</p>"   + d[whichstep].replique;

                // pour tester que les données soient bien chargées
                // console.log(d);
                var temp = d;

                // colnames donne le nom de toutes les colonnes grâce à la fonction Object.keys
                // avec [0] on choisit la première ligne, celle des en-têtes
                // mais nous n'en aurons peut-être pas besoin si nous n'utilisons que nodes_names
                var colnames = Object.keys(d[0]);

                // ici les noms des personnages, qui donnent aussi les "keys" du tableau de données
                // Ce sont les noms obtenus au stade précédent après exclusion des 4 premières colonnes
                var nodes_names = colnames.slice(4, colnames.length);

                // node5 est composé d'un objet par noeud
                // chaque noeud a un nom (key) et un array qui donne tous ses états
                var node5 = [];

                // variables d'optimisation
                var number_of_nodes = nodes_names.length;
                var number_of_data = d.length;

                // On boucle tout d'abord sur les noeuds
                for (var i = 0; i < number_of_nodes; i++) {
                    var arr1 = [];

                    // Puis on boucle sur les répliques et on enregistre l'état du noeud (0 ou 1)
                    for (var j = 0; j < number_of_data; j++) {
                        arr1.push(+d[j][nodes_names[i]]);
                    }

                    // Ici on sauve la liste des états dans node5 ainsi que le nom et la position fixe au début
                    node5.push({
                        name: nodes_names[i],
                        // x: Math.random()*w,
                        // y: Math.random()*h,
                        fixed: false,
                        step: arr1,
                    });
                }

                // Le poids des arêtes est défini comme la proportion des répliques
                // où deux personnages sont en co-presence
                var edge5 = [];

                // On boucle sur tous les noeuds ("source")
                for (var i = 0; i < number_of_nodes-1; i++) {

                    // On boucle sur les noeuds qu'il reste à parcourir ("target")
                    for (var j = i+1; j < number_of_nodes; j++) {

                        // nb_copresences va servir à sommer le nombre total de co-présences
                        var nb_copresences = 0;

                        // arr2 enregistre les états d'une arête donnée
                        arr2 = [];

                        // activated enregistre si l'arête a déjà été parcourue
                        var activated = 0;

                        // On parcourt toutes les répliques
                        for (var k = 0; k < number_of_data; k++) {

                            // coprésence vaut 1 si à la réplique k les sommets i et j sont co-présents et 0 sinon
                            var copresence = d[k][nodes_names[i]] * d[k][nodes_names[j]];

                            // On additionne au résultat précédent
                            nb_copresences += copresence;

                            arr2.push(activated + copresence);

                            // Activated permettra de savoir à l'étape suivante si la co-présence existait ici.
                            if (copresence === 1) {activated = 1;}
                        }

                        // Si l'arête existe, elle est enregistrée avec ses deux extrémités et un poids égal à son 
                        // nombre de co-présences divisé par le nombre de répliques. C'est une manière de mesurer 
                        // l'importance de cette relation (qui ne prend pas en compte la longueur des répliques 
                        // malheureusement). 
                        if (nb_copresences > 0) {
                            edge5.push({
                                source: i,
                                target: j,
                                value: nb_copresences/number_of_data,
                                step: arr2,
                            });
                        }
                    }
                }

                // On associe nodes et edges, qui sont des objects composés de pleins de trucs, dans un autre objet,
                // dataset, qui va servir à réunir les données pour la création du graphe.
                var dataset = {nodes: node5, edges: edge5};

                //Initialize a default force layout, using the nodes and edges in dataset
                var force = d3.layout.force()
                                     .nodes(dataset.nodes)
                                     .links(dataset.edges)
                                     .size([0.9*w, 0.98*h])
                                     .linkDistance(function(d) { return h/2*(1-d.value); })
                                     .charge(-h/2)
                                     .start();

                //Create SVG element (responsive)
                var svg = d3.select("div#conteneurReseau")
                            .append("svg")
                            .attr("id", "playgraph")
                             //better to keep the viewBox dimensions with variables
                            .attr("viewBox", "0 0 " + w + " " + h )
                            .attr("preserveAspectRatio", "xMaxYMax")
                            .on("click", function() {
                                whichstep++;
                                trans();
                            });
                
                //Create edges as lines
                var edges = svg.selectAll("line")
                    .data(dataset.edges)
                    .enter()
                    .append("line")
                    .style("stroke", function(d) {
                        if (d.step[0] === 1) {return "#cccccc";} 
                        else if (d.step[0] === 2) {return "#ff6600";}
                    })
                    .style("stroke-width", function(d) {
                        if (d.step[0] >= 1) {return 1;} else {return 0;}
                    });

                //Create nodes as circles
                var nodes = svg.selectAll("circle")
                    .data(dataset.nodes)
                    .enter()
                    .append("circle")
                    .attr("r", 10)
                    .style("fill", function(d) {
                        if (d.step[0]) {return "#1f77b4";} else {return "#ff7f0e";}
                    });

                // ajout des noms des personnages à chaque noeud
                var labels = svg.selectAll("text")
                    .data(dataset.nodes)
                    .enter()
                    .append("text")
                    .text(function(d) { return d.name; });

                //When force layout ends, this will be called
                force.on("tick", function() {
                    nodes.attr("cx", function(d) { return d.x; })
                         .attr("cy", function(d) { return d.y; });
                    edges.attr("x1", function(d) { return d.source.x; })
                         .attr("y1", function(d) { return d.source.y; })
                         .attr("x2", function(d) { return d.target.x; })
                         .attr("y2", function(d) { return d.target.y; });
                    labels.attr("x", function(d) { return d.x + 10; })
                          .attr("y", function(d) { return d.y - 10; });
                    });

                //Transition
                var trans = function() {
                    element.innerHTML = "<p>Pièce</p>" + d[whichstep].piece 
                    + "<p>Acte</p>" + d[whichstep].acte  
                    + "<p>Scène</p>" + d[whichstep].scene 
                    + "<p>Réplique</p>" +d[whichstep].replique;
                    svg.selectAll("circle")
                        .transition()
                        .duration(step_duration)
                        .style("fill", function(d) {
                            if (d.step[whichstep] === 1) {return "#1f77b4";} else {return "#ff7f0e";}
                        });
                    svg.selectAll("line")
                        .transition()
                        .duration(step_duration)
                        .style("stroke", function(d) {
                            if (d.step[whichstep] === 1) {return "#cccccc";} 
                            else if (d.step[whichstep] === 2) {return "#ff6600";}
                        })
                        .style("stroke-width", function(d) {
                            if (d.step[whichstep] >= 1) {return 1;} else {return 0;}
                        });
                    whichstep++;
                    if (whichstep === dataset.nodes[0].step.length) {
                        whichstep = 0;
                    }
                    else {
                        setTimeout(function(){trans();}, step_duration);
                    }
                };

                d3.select('#slider').call(d3.slider().min(1).value(1).max(temp.length).on("slide", function(evt, value) {
                    d3.select('#slidertext').text(Math.round(value));
                }));
            });
        }());
        </script>
    </body>
</html>
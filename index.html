<!DOCTYPE html>
<!-- Initial code was (long ago) 04_force.html by Scott Murray -->
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Network transition</title>
        <script src="include/js/d3.v3.js" charset="utf-8"></script>
        <script src="include/js/d3.slider.js" charset="utf-8"></script>
        <link rel="stylesheet" href="include/css/d3.slider.css" />
        <link rel="stylesheet" href="include/css/styles.css" />   
    </head>
    <body>
        <div id='conteneurPrincipal'>
            <div id='step'></div>
            <div>Slider with slide event: <span id="slidertext">1</span></div>
            <div id='slider'></div>
            <div id='conteneurReseau'></div>
            <div id='conteneurTexte'>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quaerat voluptate dignissimos maxime adipisci asperiores cumque, ut eum earum consequuntur odio laboriosam aut nihil laudantium soluta, et, nulla veniam quod similique.</div>
        </div>
        <script type="text/javascript">
        // ajout d'une closure, à limiter aux variables globales une fois le script finalisé
        (function (){
            // Largeur et hauteur de la fenêtre où apparaît le réseau
            var w = 640;
            var h = 480;
            
            // La rapidité d'animation en ms
            var step_duration = 100;

            // Import data

            // whichstep nous donne l'état du réseau
            var whichstep = 0;

            // La variable temp permet d'appeler le tableau de données en dehors de d3.tsv, par exemple dans la console
            var temp = [];

            // Importation des noeuds et gestion des fichiers à l'intérieur de la fonction d3.tsv
            // pour pallier aux problèmes d'asychronisme de JavaScript
            d3.tsv("../data/moliere/l_ecole_des_femmes_personnages.txt", function(d) {

                // On sélectionne le div dont l'"id" est "step"
                var element = document.getElementById("step");

                // Dans ce div, on ajoute quatre paragraphes chacun suivi d'un nombre lui correspondant
                element.innerHTML = "<p>Pièce</p>"      + d[whichstep].piece 
                                  + "<p>Acte</p>"       + d[whichstep].acte  
                                  + "<p>Scène</p>"      + d[whichstep].scene 
                                  + "<p>Réplique</p>"   + d[whichstep].replique;

                // pour tester que les données soient bien chargées
                // console.log(d);
                var temp = d;

                // colnames donne le nom de toutes les colonnes grâce à la fonction Object.keys
                // avec [0] on choisit la première ligne, celle des en-têtes
                // mais nous n'en aurons peut-être pas besoin si nous n'utilisons que nodes_names
                var colnames = Object.keys(d[0]);

                // ici les noms des personnages, qui donnent aussi les "keys" du tableau de données
                // Ce sont les noms obtenus au stade précédent après exclusion des 4 premières colonnes
                var nodes_names = colnames.slice(4, colnames.length);

                // node5 est composé d'un objet par noeud
                // chaque noeud a un nom (key) et un array qui donne tous ses états

                var tmp_nodes = [];

                // variables d'optimisation
                var number_of_nodes = nodes_names.length;
                var number_of_data = d.length;

                // On boucle tout d'abord sur les noeuds
                for (var i = 0; i < number_of_nodes; i++) {
                    var tmp_node_states = [];

                    // Puis on boucle sur les répliques et on enregistre l'état du noeud (0 ou 1)
                    for (var j = 0; j < number_of_data; j++) {
                        tmp_node_states.push(+d[j][nodes_names[i]]);
                    }

                    // Ici on sauve la liste des états dans tmp_nodes ainsi que le nom et la position fixe au début
                    tmp_nodes.push({
                        name: nodes_names[i],
//                      x: Math.random()*w,
//                      y: Math.random()*h,
                        fixed: false,       // mis ceci a false, AX
                        step: tmp_node_states,
                    });
                }

                // Precalcul des états et poids des arêtes; le poids est 
                // defini comme la proportion des repliques ou les deux 
                // personnages en question sont copresents; 4 etats sont
                // possibles:
                // - never_live (NL)
                // - not_yet_live (NYL)
                // - previously_live (PL)
                // - live (L)
                var tmp_edges = [];
                // Pour chaque paire de noeuds...
                for (var i = 0; i < number_of_nodes-1; i++) {
                    for (var j = i+1; j < number_of_nodes; j++) {
                        var tmp_state_array = []
                        // Calculer le nombre total de copresences et
                        // construire le vecteur des copresences...
                        var num_copresences = 0;
                        var copresences = []
                        for (var k = 0; k < number_of_data; k++) {
                            var copresence = d[k][nodes_names[i]] 
                                           * d[k][nodes_names[j]]
                                           ;
                            num_copresences += copresence;
                            copresences.push(copresence)
                        }
                        // Si ces noeuds ne sont jamais copresents...
                        if (num_copresences === 0) {
                            // Tous les etats sont NL.
                            tmp_state_array = Array
                                              .apply(null, Array(d.length))
                                              .map(
                                                  function() {
                                                      return 'never_live'
                                                  }
                                               );
                        }
                        // Si ces noeuds sont copresents au moins une fois...
                        else {
                            // Initialisations...
                            var has_been_live = 0;
                            var tmp_state_array = [];
                            // Pour chaque replique...
                            for (var k = 0; k < number_of_data; k++) {
                                // Si ces noeuds sont copresents => L 
                                if (copresences[k] === 1) {
                                    tmp_state_array.push('live')
                                    has_been_live = 1;
                                }
                                // Sinon, s'ils ont deja ete copresents => PL
                                else if (has_been_live === 1) {
                                    tmp_state_array.push('previously_live')
                                }
                                // Sinon => NYL
                                else {
                                    tmp_state_array.push('not_yet_live')
                                }
                            }
                        }
                        // Stocker le poids et la sequence d'etats...
                        tmp_edges.push({
                            source: i,
                            target: j,
                            value:  num_copresences/d.length,
                            step:   tmp_state_array,
                        })
                    }
                }

                // On associe nodes et edges, qui sont des objects composés de pleins de trucs, dans un autre objet,
                // dataset, qui va servir à réunir les données pour la création du graphe.
                var dataset = {nodes: tmp_nodes, edges: tmp_edges};

                //Initialize a default force layout, using the nodes and edges in dataset
                var force = d3.layout.force()
                                     .nodes(dataset.nodes)
                                     .links(dataset.edges)
                                     .size([0.9*w, 0.98*h])
                                     .linkDistance(function(d) { return h/2*(1-d.value); })
                                     .charge(-h/2)
                                     .start();

                //Create SVG element (responsive)
                var svg = d3.select("div#conteneurReseau")
                            .append("svg")
                            .attr("id", "playgraph")
                             //better to keep the viewBox dimensions with variables
                            .attr("viewBox", "0 0 " + w + " " + h )
                            .attr("preserveAspectRatio", "xMaxYMax")
                            .on("click", function() {
                                whichstep++;
                                trans();
                            });
                
                // Creation des aretes comme lignes...
                var edges = svg.selectAll("line")
                    .data(dataset.edges)
                    .enter()
                    .append("line")
                    .style("stroke", function(d) {
                        if (d.step[0] === 'not_yet_live') {return "#eeeeee";}
                        else if (d.step[0] === 'previously_live') {return "#1177bb";}
                        else if (d.step[0] === 'live') {return "#ff6600";}
                    })
                    .style("stroke-width", function(d) {
                        if (d.step[0] != 'never_live') {return 1;} else {return 0;}
                    });

                // Creation des noeuds comme cercles...
                var nodes = svg.selectAll("circle")
                    .data(dataset.nodes)
                    .enter()
                    .append("circle")
                    .attr("r", 10)
                    .style("fill", function(d) {
                        if (d.step[0]) {return "#ff6600";} else {return "#1177bb";}
                    });

                // ajout des noms des personnages à chaque noeud
                var labels = svg.selectAll("text")
                    .data(dataset.nodes)
                    .enter()
                    .append("text")
                    .text(function(d) { return d.name; });

                //When force layout ends, this will be called
                force.on("tick", function() {
                    nodes.attr("cx", function(d) { return d.x; })
                         .attr("cy", function(d) { return d.y; });
                    edges.attr("x1", function(d) { return d.source.x; })
                         .attr("y1", function(d) { return d.source.y; })
                         .attr("x2", function(d) { return d.target.x; })
                         .attr("y2", function(d) { return d.target.y; });
                    labels.attr("x", function(d) { return d.x + 10; })
                          .attr("y", function(d) { return d.y - 10; });
                    });

                //Transition
                var trans = function() {
                    element.innerHTML = "<p>Pièce</p>" + d[whichstep].piece 
                    + "<p>Acte</p>" + d[whichstep].acte  
                    + "<p>Scène</p>" + d[whichstep].scene 
                    + "<p>Réplique</p>" +d[whichstep].replique;
                    svg.selectAll("circle")
                        .transition()
                        .duration(step_duration)
                        .style("fill", function(d) {
                            if (d.step[whichstep]) {return "#ff6600";} else {return "#1177bb";}
                        });
                    svg.selectAll("line")
                        .transition()
                        .duration(step_duration)
                    .style("stroke", function(d) {
                        if (d.step[whichstep] === 'not_yet_live') {return "#eeeeee";}
                        else if (d.step[whichstep] === 'previously_live') {return "#1177bb";}
                        else if (d.step[whichstep] === 'live') {return "#ff6600";}
                    })
                    .style("stroke-width", function(d) {
                        if (d.step[whichstep] != 'never_live') {return 1;} else {return 0;}
                    });
                    whichstep++;
                    if (whichstep === dataset.nodes[0].step.length) {
                        whichstep = 0;
                    }
                    else {
                        setTimeout(function(){trans();}, step_duration);
                    }
                };

                d3.select('#slider').call(d3.slider().min(1).value(1).max(temp.length).on("slide", function(evt, value) {
                    d3.select('#slidertext').text(Math.round(value));
                }));
            });
        }());
        </script>
    </body>
</html>